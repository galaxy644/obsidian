### Задание с ограниченным временемДедлайн: 23 апр. 16:55

|   |   |   |
|---|---|---|
||**Все языки**|**C# (MS .NET 6.0 + ASP)**|
|Ограничение времени|**8 секунд**|10 секунд|
|Ограничение памяти|**512Mb**|512Mb|
|Ввод|**стандартный ввод или input.txt**||
|Вывод|**стандартный вывод или output.txt**||

Необъяснимая аномалия! На серверах Яндекс Маркета отказывает оборудование: ломаются жесткие диски, плавится оперативная память, выходит из строя система охлаждения. Системные администраторы локализовали проблему — причиной поломок оказалась используемая база данных. Руководители приняли решение срочно вывести из эксплуатации упомянутую базу данных и заменить ее самописной. Вам нужно как можно скорее предоставить MVP, который поддерживает:

- частичное обновление товарных предложений в базе данных
- уведомление сервисов-подписчиков при обновлении данных

Товарное предложение в базе описывается следующей JSON схемой:

{    "$id": "offer.schema.json",    "type": "object",    "properties": {      "id": {        "type": "string",        "description": "Offer identifier, only numerical symbols are allowed"      },      "price": {        "type": "integer",        "description": "Offer price, value in range from 0 to 10̂9"      },      "stock_count": {        "type": "integer",        "description": "Items left on stocks, value in range from 0 to 10̂9"      },      "partner_content": {        "type": "object",        "properties": {          "title": {            "type": "string",            "description": "Offer title filled in by the partner"          },          "description": {            "type": "string",            "description": "Offer description filled in by the partner"          }        }      }    },    "required": [      "id"    ]  }

При межсервисном взаимодействии к товарному предложению добавляется контекст, который содержит идентификатор для сквозной трассировки, его схема:

{    "$id": "message.schema.json",    "type": "object",    "properties": {      "trace_id": {        "type": "string"      },      "offer": {        "$ref": "offer.schema.json"      }    },    "required": [      "trace_id",      "offer"    ]  }

Сервис, который отправляет запрос на обновление товарного предложения, обязательно заполняет идентификатор оффера (поле offer.id�����.��) и идентификатор для трассировки (поле trace_id�����_��). Все остальные поля в запросе опциональны. В таком случае при применении обновления будет происходить слияние полей. Например, в базе у оффера заполнены поля price=9990�����=9990, и приходит обновление stock_count=100�����_�����=100, тогда в базе будут сохранены оба поля price=9990;stock_count=100�����=9990;�����_�����=100. Гарантируется, что все входящие запросы валидны и соответствуют схеме. Так как это прототип, удаление товаров из базы и очищение полей было решено не поддерживать.

Помимо хранения товарных предложений в базе, в сервисе необходима функция доставки обновлений в сервисы-подписчиков. Одна подписка включает в себя два набора полей: trigger и shipment, не обязательно листовых. Когда изменяется любое trigger поле **или** поле, вложенное в trigger поле, подписчику отправляется сообщение. В сообщении находятся все shipment и trigger поля этого подписчика, а также идентификаторы оффера и трассировки из запроса, который привел к этому сообщению. Инициализация поля также считается за его изменении и создает сообщение об обновлении.

## Формат ввода

Первая строка входных данных содержит два целых числа n

�

и m

�

(1≤n≤50,1≤m≤10,000

1≤�≤50,1≤�≤10,000

) — количество сервисов подписчиков и количество запросов на обновления.

Следующие n� строк содержат описания сервисов подписчиков: i�-я строка содержит описание i�-го подписчика. В начале строки задается ai�� и bi�� — количество trigger и shipment полей соответственно. Далее ai�� trigger полей, и bi�� shipment полей.

Следующие m� строк содержат запросы на обновление, каждая строка — это валидный json, удовлетворяющий схеме message.schema.json�������.��ℎ���.����.

## Формат вывода

На каждое событие обновления выведите kj�� сообщений в формате message.schema.json�������.��ℎ���.����, где kj�� — это количество сервисов-подписчиков, которым данное событие интересно. Сообщения должны идти в том же порядке, что и обновления, которые привели к ним. Сообщения в рамках одного обновления должны быть отсортированы по порядковому номеру подписчика.

## Пример

|   |   |
|---|---|
|**Ввод**|**Вывод**|
|`2 5 2 0 price stock_count 1 0 partner_content {"trace_id": "1", "offer": {"id": "1", "price": 9990}} {"trace_id": "2", "offer": {"id": "1", "stock_count": 100}} {"trace_id": "3", "offer": {"id": "2", "partner_content": {"title": "Backpack"}}} {"trace_id": "4", "offer": {"id": "1", "stock_count": 100}} {"trace_id": "5", "offer": {"id": "2", "partner_content": {"description": "Best backpack ever"}}}`|`{"trace_id":"1","offer":{"id":"1","price":9990}} {"trace_id":"2","offer":{"id":"1","price":9990,"stock_count":100}} {"trace_id":"3","offer":{"id":"2","partner_content":{"title":"Backpack"}}} {"trace_id":"5","offer":{"id":"2","partner_content":{"description":"Best backpack ever","title":"Backpack"}}}`|

## Примечания

Для решений на языке **C++** доступна библиотека [**nlohmann/json**](https://github.com/nlohmann/json/releases/tag/v3.8.0) v3.8.0. Соответствующая директива include выглядит так:

\#include "json.hpp"

  

[[SQL]]