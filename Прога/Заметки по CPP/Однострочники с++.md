### **1. Алгоритм Евклида**

Рекурсивный алгоритм нахождения наибольшего общего делителя.

```Plain
intGCD(int a,int b) {
return b?GCD(b,a%b):a;
}
```

### **2. Нахождение НОК**

Рекурсивный алгоритм нахождения наименьшего общего кратного.

```Plain
intLCM(int a,int b) {
return a/GCD(a,b) * b;
}
```

### **3. Проверка числа 2^n**

Алгоритм проверки числа на степень 2.

```Plain
intisPow2(int a) {
return !(a&(a-1));
}
```

### **4. Функция обмена двух переменных**

Этот алгоритм работает при помощи свойства симметричного различия, которым обладает XOR и не требует наличия третей переменой.

```Plain
voidswap(int *a,int *b) {
    *a ^= (*b ^= (*a ^= *b));
}
```

### **5. Алгоритм возведения в степень**

Степень числа за линейное время.

Условие окончания рекурсии: если степень числа равно 0, то a^0=1.

```Plain
intpow(int a,int n) {
return (!n)?1:a*pow(a,n-1);
}
```

### **6. Индийский алгоритм возведения в степень**

Степень числа за логарифмическое время.

```Plain
intpowInd(int a,int n) {
return (!n)?1:((n&1)?a:1)*powInd(a*a,n/2);
}
```

### **7. Факториал числа**

Факториал целого неотрицательного числа n.

Условие продолжения рекурсии: факториал ето произведение всех натуральных чисел до n включительно.

Условие окончания рекурсии: если число равно 0, то 0!=1.

```Plain
intfac(int n) {
return n?n*fac(n-1):1;
}
```

### **8. Сумма цифр числа**

Условие продолжения рекурсии: сума цифр числа равна последней цифре плюс сума цифр числа без последней цифры.

Условие окончания рекурсии: если число равно 0, то и сума цифр равна 0.

```Plain
intcount(int a) {
return (!a)?0:(a%10+count(a/10));
}
```

### **9. Числа Фибоначчи**

Числа Фибоначчи — элементы числовой последовательности в которой каждое последующее число равно сумме двух предыдущих чисел.

```Plain
intfib(int n) {
return (n<=2)?1:(fib(n-1)+fib(n-2));
}
```

### **10. Следующее число Фибоначчи**

Функция нахождения чисел Фибоначчи.

```Plain
intfibNext(int &f1,int &f2) {
return f1=(f2+=f1)-f1;
}
```

### **11. Числа Мерсенна**

Числа Мерсе́нна — числа вида

[![](http://upload.wikimedia.org/wikipedia/ru/math/e/3/2/e321c23ac7f9cca1f0fd1726f7af94a8.png)](http://upload.wikimedia.org/wikipedia/ru/math/e/3/2/e321c23ac7f9cca1f0fd1726f7af94a8.png)

```Plain
intMersen(int n) {
return !(n&(n+1));
}
```

### **12. Min & Max**

```Plain
intmax(int a,int b) {
return (a>b)?a:b;
}

intmin(int a,int b) {
return (a>b)?b:a;
}
```

### **13. Сравнение двух чисел**

Функция возвращает значение разницы между двумя числами, поэтому если разница больше 0, то число a больше b, если равна 0, то числа одинаковы, иначе число a меньше b.

```Plain
template <typename TYPE>
intcompare (const TYPE a,const TYPE b){
return ( a - b );
}
```

### **14. Возведение числа 2 в степень n**

C помощью сдвига единицы на n битов ми вычислим двойку в степени n.

```Plain
intpow2(int n) {
return 1<<n;
}
```

### **Нахождение НОК от** [**Lertmind**](http://habrahabr.ru/users/lertmind/)

```Plain
intlcm(int a,int b) {
return (b < 1 ? (b ? lcm(b, a % b) : a) : (a / -lcm(-b, -a % b) * b));
}
```

### **Число ненулевых битов в числе**

```Plain
intNBit(unsignedint x){
return x==0 ? 0 : (x&1)+NBit(x>>1);
}
```

### **Максимальная степень двойки, на которую делится n**

```Plain
intMaxDivPow2(int n){
return n&-n;
}
```

### **Сравнение двух чисел**

```Plain
intcmp(int a,int b) {
return (a < b ? -1 : (a > b ? 1 : 0));
}
```

или шаблон

```Plain
template<typename T>
intcmp(const T &a,const T &b) {
return (a < b ? -1 : a > b);
}
```

### **Найти k-й бит в массиве int * (считая, что sizeof(int)==4)**

```Plain
intGetBit(int *a,int k){
return (a[k>>5]>>(k&31))&1;
}
```

### **1. Проверка на простоту**

Для вызова этой функции надо написать

```Plain
prime(100, int(sqrt(100)));
```

```Plain
boolprime(int n,int div) {
return ( div == 1) ? true : (n % div != 0) && (prime(n, div-1));
}
```

Чтобы этого избежать можно создать функцию-оболочку:

```Plain
boolprime(int n) {
return ( n == 1 )? 0 : ( prime( n,int(sqrt(n))) ) ;
}
```

и теперь для вызова функции достаточно написать

```Plain
prime(100)
```

### **2. Код Грея**

Кодом Грея называется такая система нумерования неотрицательных чисел, когда коды двух соседних чисел отличаются ровно в одном бите.

```Plain
intcodeGrey (int n) {
return n ^ (n >> 1);
}
```

А также нахождение обратного кода Грея

```Plain
intrevCodeGrey (int g) {
int n;
for (n=0; g; n ^=g, g>>=1);
return n;
}
```

Коды Грея имеют несколько применений в различных областях:

- битный код Грея соответствует гамильтонову циклу по n-мерному кубу
- в решении задачи о Ханойских башнях
- применение в теории генетических алгоритмов

### **3. Вычисление биномиального коэффициента**

Биномиальный коэффициент — это коэффициент в разложении бинома Ньютона

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/e0e/b02/901/e0eb02901675dba4a3e2108cf722f9cc.png)](https://habrastorage.org/r/w1560/getpro/habr/post_images/e0e/b02/901/e0eb02901675dba4a3e2108cf722f9cc.png)

по степеням x.

```Plain
intbinomialCoefficient(int k,int n) {
return (n==k || k==0)?1:binomialCoefficient(k-1,n-1)+binomialCoefficient(k,n-1);
}
```

### **4. Нахождение степени делителя факториала**

Даны два числа: [n] и [k]. Требуется посчитать, с какой степенью делитель [k] входит в число [n].

```Plain
intfactPow(int n,int k) {
return (n)? (n/k + factPow(n/k, k)):0;
}
```

### **5. Возведение числа [a] в степень [b] по модулю [p].**

```Plain
ntpowM(int a,int b,int p) {
return b ? (a * powM(a-1, b, p) % p) : 1;
}
```

Также здесь можно использовать индийский алгоритм возведения в степень.

```Plain
intpowM(int a,int b,int p) {
return b ? ((b&1?a:1)*powM(a*a, b/2, p) % p) : 1;
}
```

---