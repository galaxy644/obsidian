**Операции языка С++ для работы с динамической памятью**

В языке C++ для захвата и освобождения динамической памяти используются операции new и delete. Они являются частью языка C++ (в отличие от функций malloc() и free(), которые в состав языка С не входят).

Пусть T - некоторый тип языка  C++, p - указатель на объект типа T. Тогда для захвата памяти размером в один элемент типа T используется операция new:

```C++
T *p;
p = new T;
```

Например, для размещения в динамической памяти вещественного числа типа double используется фрагмент

```C++
double *p;
p = new double;
```

Если нужное количество памяти выделить не удалось (такое встречается очень редко), то возникает исключение, т.е. ошибка во время выполнения программы.

При использовании new, в отличие от malloc, не нужно выполнять приведение типа: операция new возвращает указатель на тип, записанный после слова new.  Требуемый размер памяти тоже вычисляется автоматически. Сравните два эквивалентных фрагмента на Си и C++:

[![](https://ucarecdn.com/80981c1d-9362-4a3f-b8d0-19f5aff999c5/)](https://ucarecdn.com/80981c1d-9362-4a3f-b8d0-19f5aff999c5/)

Конечно, второй фрагмент гораздо короче и нагляднее.

Операция new удобна еще и тем, что можно сразу присвоить начальное значение объекту, созданному в динамической памяти (т.е. выполнить инициализацию объекта). Для этого начальное значение записывается в круглых скобках после имени типа, следующего за словом new. Например, в приведенной ниже строке захватывается память под вещественное число, которому присваивается начальное значение 1.5:

```C++
double *p = new double(1.5);
```

Это эквивалентно двум операторам:

```C++
double *p = new double;
*p = 1.5;
```

С помощью операции new можно занять память под массив элементов заданного типа. Для этого в квадратных скобках указывается длина  массива, которая может представляться любым целочисленным выражением. Например,  в динамической памяти выделяется область для хранения вещественного массива из 10 элементов:

```C++
double *a;
a = new double[10];
```

Такую форму операции new  называют векторной. При размещении массива в динамической памяти его нельзя инициализировать.

Операция delete освобождает память, захваченную ранее с помощью операции new. Аргументом этой операции  должен быть указатель,  значение которого установлено на начало выделенной памяти. Например:

```C++
double *p = new double(1.5); // Захват и инициализация
. . .
delete p; // Освобождение памяти
```

Если память под массив была захвачена с помощью векторной формы операции new, то для ее освобождения следует использовать векторную форму оператора delete, в которой после слова delete записываются пустые квадратные скобки:

```C++
int size=10;
double *a = new double[size]; // занимаем память под массив
. . .
delete[] a; // Освобождаем память
```

После освобождения  памяти нельзя использовать значение указателя, который ранее был установлен на начало выделенной памяти (указатели  p и a в примерах выше). Попытка разыменования этого указателя или попытка повторного оcвобождения памяти может привести к ошибке (это зависит от того, была ли эта память выделена вновь другому процессу). Поэтому  хорошим стилем является "обнуление" указателя после освобождения памяти:

```C++
delete p;
p=NULL;
```

Приятная особенность оператора delete состоит в том, что при освобождении нулевого указателя ничего не происходит. Например, следующий фрагмент вполне корректен:

```C++
double *ptr = NULL;  // Нулевой указатель
bool b;
. . .
if (b) {
    ptr = new double[1000];
    . . .
}
. . .
delete[] ptr;
ptr=NULL;
```

В указатель _ptr_ вначале записывается нулевой адрес. Затем, если справедливо некоторое условие, захватывается память под массив. Таким образом, при выполнении операции delete указатель _ptr_ содержит либо нулевое значение, либо адрес массива. В первом случае оператор delete ничего не делает, во втором освобождает память, занятую массивом. Такая технология применяется практически всеми программистами на C++: всегда инициализировать указатели на динамическую память нулевыми значениями и в результате не иметь никаких проблем при освобождении памяти.

Для сравнения: попытка освобождения нулевого указателя с помощью стандартной функции free может привести к аварийному завершению программы (это зависит от используемой Си-библиотеки: нормальная работа не гарантируется стандартом ANSI).

При использовании динамической памяти нужно помнить о том, что указатель на начало выделенной памяти не должен быть "потерян", чтобы можно было эту память освободить после использования. Если это не обеспечить, то возможна "утечка памяти". Например, в приведенном ниже коде мы "теряем" указатель на выделенную память:

```C++
double *p, value=8.2;
p=new double(3.5);
p=&value; //в переменную p записали адрес переменной value,
// а адрес выделенной памяти потерян - мы не можем ее освободить
```

**Пример .** 

```C++
\#include <iostream>
\#include <time.h>
using namespace std;
int main() {
	setlocale(LC_ALL, "rus");
	int n, *ptrInt=NULL;
	cout << "Введите размер массива: ";
	cin >> n;
	ptrInt = new int[n]; //динамич.выделение памяти из кучи
	srand(time(0)); //задание начального значения генератора
	int *tempPtr = ptrInt; //вспомогательный указатель для движения по массиву
	for (int i = 0; i < n; i++, tempPtr++) {
		*tempPtr = rand() % 11; //случайные числа от 0 до 10
	}
	cout << "Получен массив:\n";
	tempPtr = ptrInt; //опять вспомогательный указатель в начало
	for (int i = 0; i < n; i++) {
		cout << tempPtr[i] << "\t";
	}
	cout << endl;
	delete[] ptrInt;
        ptrInt=NULL;
	system("pause");
	return 0;
}
```