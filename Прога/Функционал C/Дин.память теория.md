**В С++ malloc, calloc, realloc не используют. В С++ используют операторы `new` и `delete`:**

```C++
int * a = new int[10];  // это С++
delete [] a;            // это С++
```

### **Выделение и освобождение памяти stdlib.h**

- `void *` **malloc** `(size_t size);`
    - выделяет память размером `size` байт
    - возвращает указатель на выделенную память или NULL в случае ошибки
- `void *` **calloc** `(size_t nmemb, size_t size);`
    - выделяет память размером `nmemb*size`
    - **заполняет память 0**
    - возвращает указатель на выделенную память или NULL в случае ошибки
- `void` **free** `(void *ptr);`
    - освобождает память, на которую указывает `ptr` (начало динамически выделенной памяти)
    - `free(NULL)` ничего не делает
- `void *` **realloc** `(void *ptr, size_t size);`
    - выделяет память размером `size` байт
    - копирует данные из памяти, на которую указывает `ptr` в новую память
    - освобождает старую память
    - возвращает указатель на выделенную память или NULL в случае ошибки
    - при `ptr=NULL` работает как `malloc`

### **Копирование и заполнение данными string.h**

- `void *` **memcpy** `(void *dst, const void *src, size_t n);`
    - копировать `n` байт из `src` в `dst`
    - возвращает указатель на `dst`
    - **нельзя использовать на перекрывающихся участках памяти**
- `void *` **memmove** `(void *dst, const void *src, size_t n);`
    - копировать `n` байт из `src` в `dst`
    - возвращает указатель на `dst`
    - **можно использовать на перекрывающихся участках памяти**, так как сначала идет копирование `src` во временный дополнительный массив, а потом из него в `dst`.
- `void *` **memset** `(void *s, int c, size_t n);`
    
    - заполнить `n` байт числом `с`, начиная с адреса `s`
    
      
    
    **`free(ptr); free(ptr);` - неопределенное поведение (undefined behaviour)**
    
    Поэтому, если переменную `ptr` дальше используют в коде, пишите:
    
    ```Plain
    free(ptr);
    ptr = NULL;     // гарантия, что следующий free(ptr) не приведет к ошибке
    ```