char * dst = malloc(1+strlen(s1)); // +1 для хранения \0  
strcpy(dst, s1);  

char * dst = strdup(s1);// делаем тоже самое. strdup сама выделяет память

==**читаем scanf с автоматическим выделением памяти**==

```C
\#include <stdio.h>
\#include <stdlib.h>
int main()
{
char *s = NULL;                 // указатель, в него будет записываться адрес выделяемой памяти
while(1 == scanf("%ms", &s)) {  // неявный вызов malloc, обратите внимание &s
printf("<%s>\n", s);        // используем прочитанное слово
free(s);                    // освобождаем память после использования, чтобы не было утечек
}
return 0;
}
```

```C
char a1[100];
scanf("%99s", a1);       // a1 типа char *, с контролем переполнения
```

Пример: У пользователя запрашивается размер массива, а затем выделяется память нужного размера. В эту память вводятся значения элементов массива, а затем введенный массив распечатывается (предполагается какая-то дальнейшая работа с этим массивом).

```C++
\#include <iostream>
using namespace std;
\#include <time.h>
int main(){
setlocale(LC_ALL, "rus");
int n, *ptrInt;
cout << "Введите размер массива: ";
cin >> n;
ptrInt = (int *)malloc(n * sizeof(int)); //динамич.выделение памяти из кучи
srand(time(0)); //задание начального значения генератора
int *tempPtr = ptrInt; //вспомогательный указатель для движения по массиву
for (int i = 0; i < n; i++, tempPtr++) {
*tempPtr=rand()%11; //случайные числа от 0 до 10
}
cout << "Получен массив:\n";
tempPtr = ptrInt; //опять вспомогательный указатель в начало
for (int i = 0; i < n; i++, tempPtr++) {
cout << *tempPtr << "\t";
}
cout << endl;
free(ptrInt); //освобождение памяти
system("pause");
return 0;
}
```